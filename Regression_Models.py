# -*- coding: utf-8 -*-
"""Copia de EDARegressionAVGSaveModel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/128WKkRuP0hQJdejLUcRWCPwc5L7cvHp_
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sb

from sklearn.model_selection import train_test_split

from sklearn.linear_model import LinearRegression # OLS algorithm
from sklearn.linear_model import Ridge # Ridge algorithm
from sklearn.linear_model import Lasso # Lasso algorithm
from sklearn.linear_model import BayesianRidge # Bayesian algorithm
from sklearn.linear_model import ElasticNet # ElasticNet algorithm
from sklearn.linear_model import LinearRegression

from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVR

from sklearn.ensemble import RandomForestRegressor

from sklearn.metrics import explained_variance_score as evs # evaluation metric
from sklearn.metrics import r2_score as r2 # evaluation metric

from sklearn.metrics import mean_squared_error as mse
from sklearn.metrics import mean_absolute_error as mae

sb.set_style('whitegrid') # plot style
plt.rcParams['figure.figsize'] = (20, 10) # plot size

from google.colab import drive
drive.mount('/content/drive')

ROOT_PATH = "resources/Result4/"
INPUT_FILE_NAME = "PruebasEvaluacion2.xlsx"
OUTPUT_FILE_NAME = "Evaluations/scikit/excel/carril_2.xlsx"
OUTPUT_MODEL_PATH = "Evaluations/scikit/2"
SHEET_NAME = 5
SKIP_ROWS = 4
EVALUATIONS = 800

SAVE_MODEL = True
SAVE_IMG = True

df = pd.read_excel(ROOT_PATH + INPUT_FILE_NAME,
                   engine="openpyxl",
                   sheet_name=SHEET_NAME,
                   skiprows=SKIP_ROWS
                  )

column_names = ['Linear Regression','Ridge','Lasso',
                'Bayesian','Elastic Net','Random Forest Regression',
                'Suport Vector Machine Regression']
df_evs = pd.DataFrame(columns=column_names)
df_r2 = pd.DataFrame(columns=column_names)
df_mse = pd.DataFrame(columns=column_names)
df_mae = pd.DataFrame(columns=column_names)
df_c_mae = pd.DataFrame(columns=column_names)

def get_x_y(df):
    df2 = df.copy().sample(frac=1)
    X = df2[["DistanciaPixeles", "Tiempo"]]
    Y = df2[["V M/S"]]
    return X, Y

def run_train(X, Y, root_path, id, test_size=0.3, save_model = True):
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size= test_size)
    
    X_test_order = X_test.copy()
    X_test_order["V M/S"] = Y_test.copy()
    X_test_order = X_test_order.sort_values(by="V M/S")

    X_test = X_test_order[["DistanciaPixeles", "Tiempo"]]
    Y_test = X_test_order[["V M/S"]]

    from joblib import dump as dump_model
    # from pickle import dumps as dump_model
    # 1. OLS
    ols = LinearRegression()
    ols.fit(X_train, Y_train)
    ols_y = ols.predict(X_test)
    
    print(ols.get_params)

    if save_model:
        with open('{}/ols_{}.joblib'.format(root_path, id), "wb") as f:
            dump_model(ols, f)
    
    # 2. Ridge
    ridge = Ridge(alpha = 0.5)
    ridge.fit(X_train, Y_train)
    ridge_y = ridge.predict(X_test)
    
    if save_model:
        with open('{}/ridge_{}.joblib'.format(root_path, id), "wb") as f:
            dump_model(ridge, f)
    
    # # 3. Lasso
    lasso = Lasso(alpha = 0.01)
    lasso.fit(X_train, Y_train)
    lasso_y = lasso.predict(X_test)
    
    if save_model:
        with open('{}/lasso_{}.joblib'.format(root_path, id), "wb") as f:
            dump_model(ridge, f)

    # # 4. Bayesian
    bayesian = BayesianRidge()
    bayesian.fit(X_train, Y_train.values.ravel())
    bayesian_y = bayesian.predict(X_test)
    
    if save_model:
        with open('{}/bayesian_{}.joblib'.format(root_path, id), "wb") as f:
            dump_model(ridge, f)

    # # 5. ElasticNet
    en = ElasticNet(alpha = 0.01)
    en.fit(X_train, Y_train)
    en_y = en.predict(X_test)
    
    if save_model:
        with open('{}/en_{}.joblib'.format(root_path, id), "wb") as f:
            dump_model(ridge, f)

    # 7. Random Forest Regression
    random_f = RandomForestRegressor(n_estimators = 100,
                                  criterion = 'mae',
                                  random_state = 1,
                                  n_jobs = -1)
    random_f.fit(X_train, Y_train.values.ravel())
    rf_y = random_f.predict(X_test)
    
    if save_model:
        with open('{}/random_f_{}.joblib'.format(root_path, id), "wb") as f:
            dump_model(ridge, f)

    # log_regr = LogisticRegression()
    # log_regr.fit(X_train, Y_train)
    # log_regr_y = log_regr.predict(X_test)

    # Suport Vector Machine
    svr_model = SVR()
    svr_model.fit(X_train, Y_train.values.ravel())
    svr_y = svr_model.predict(X_test)
    
    if save_model:
        with open('{}/svr_f_{}.joblib'.format(root_path, id), "wb") as f:
            dump_model(ridge, f)
    
    return [ols_y, ridge_y, lasso_y, bayesian_y, en_y, rf_y, svr_y], Y_test

def c_mae(Y_real, Y_predict):
    mae = np.absolute(np.subtract(Y_real, Y_predict)).mean()
    return mae;

def get_eval(predict_arr, Y_test, df, met = evs):
    
    new_row = [met(Y_test.values.flatten(), Y_predict.flatten()) for Y_predict in predict_arr]
    new_row = np.array(new_row).reshape((-1, len(new_row)))
    
    
#     new_row_2 = [c_mae(Y_test.values.flatten(), Y_predict.flatten()) for Y_predict in predict_arr]
#     new_row_2 = np.array(new_row_2).reshape((-1, len(new_row_2)))
    
#     df = df.append(pd.DataFrame(new_row_2, columns=column_names),
#                            ignore_index = True)
    
    return df.append(pd.DataFrame(new_row, columns=column_names),
                           ignore_index = True)

def plot_comparation(Y_test, Y_predict, path=None, show=True):

  X = list(range(len(Y_test)))

  plt.figure("Figura MAE")

  plt.plot(X, Y_test,
         label='RIGHT', color="blue",
         linestyle="", marker="o")
  plt.plot(X, Y_predict,
         label = 'WRONG', color="red",
         linestyle="", marker="o")
  plt.legend()
  if path is not None:
    plt.savefig(path)
  if show:
    plt.show()
  plt.close()

print(ols)

X, Y = get_x_y(df)
  predict_y, Y_test = run_train(X, Y,
                            "{}{}".format(ROOT_PATH, OUTPUT_MODEL_PATH) , i,
                            save_model = SAVE_MODEL)
  
  predict_y[3].g

for i in range(EVALUATIONS):
    
    X, Y = get_x_y(df)
    predict_y, Y_test = run_train(X, Y,
                            "{}{}".format(ROOT_PATH, OUTPUT_MODEL_PATH) , i,
                            save_model = SAVE_MODEL)
    
    for j in range(len(predict_y)):
        Y_predicted = predict_y[j]
        
        if SAVE_IMG:
            plot_comparation(Y_test, Y_predicted,
                         path="{}{}/imgs/{}_{}.png".format(ROOT_PATH,
                            OUTPUT_MODEL_PATH,
                            column_names[j],
                            i),
                         show=False)

    df_c_mae = get_eval(predict_y, Y_test, df_mae, met = c_mae)
    df_mae = get_eval(predict_y, Y_test, df_mae, met = mae)
    df_mse = get_eval(predict_y, Y_test, df_mse, met = mse)
    df_r2 = get_eval(predict_y, Y_test, df_r2, met = r2)
    df_evs = get_eval(predict_y, Y_test, df_evs, met = evs)

with pd.ExcelWriter(ROOT_PATH + OUTPUT_FILE_NAME) as writer:
    df_evs.to_excel(writer, sheet_name="EVS", index=True)
    df_r2.to_excel(writer, sheet_name="R2", index=True)
    df_mse.to_excel(writer, sheet_name="MSE", index=True)
    df_mae.to_excel(writer, sheet_name="MAE", index=True)
    df_c_mae.to_excel(writer, sheet_name="C_MAE", index=True)